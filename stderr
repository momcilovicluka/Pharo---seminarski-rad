[31mTestFailure: Got 'TinyBlog is a small blog engine made with Pharo.' instead of 'TinyBlog is a small blog engine
	made with Pharo.'.
[0mTBPostTest(TestAsserter)>>assert:description:resumable:
TBPostTest(TestAsserter)>>assert:description:
TBPostTest(TestAsserter)>>assert:equals:
TBPostTest>>testPostIsCreatedCorrectly
TBPostTest(TestCase)>>performTest
[self setUp.
	self performTest] in TBPostTest(TestCase)>>runCase in Block: [self setUp....
FullBlockClosure(BlockClosure)>>ensure:
TBPostTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [aTestCase runCase]
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase: in Block: [self runTestCaseUnderWatchdog: aTestCase]
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase: in Block: [...
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for: in Block: [ self value: anExecutionEnvironment....
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TBPostTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TBPostTest(TestCase)>>debug in Block: [ result runCaseForDebug: self ]
FullBlockClosure(BlockClosure)>>ensure:
TBPostTest(TestCase)>>debug
[0m[31mTestFailure: Got 'TinyBlog is a small blog engine made with Pharo.' instead of 'TinyBlog is a small blog engine
	made with Pharo.'.
[0mTBPostTest(TestAsserter)>>assert:description:resumable:
TBPostTest(TestAsserter)>>assert:description:
TBPostTest(TestAsserter)>>assert:equals:
TBPostTest>>testPostIsCreatedCorrectly
TBPostTest(TestCase)>>performTest
[self setUp.
	self performTest] in TBPostTest(TestCase)>>runCase in Block: [self setUp....
FullBlockClosure(BlockClosure)>>ensure:
TBPostTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [aTestCase runCase]
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase: in Block: [self runTestCaseUnderWatchdog: aTestCase]
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase: in Block: [...
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for: in Block: [ self value: anExecutionEnvironment....
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TBPostTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TBPostTest(TestCase)>>debug in Block: [ result runCaseForDebug: self ]
FullBlockClosure(BlockClosure)>>ensure:
TBPostTest(TestCase)>>debug
[0mdePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with: in Block: [ aCommand execute ]
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent: in Block: [ | selArgCount |  "show cursor in case item opens...etc...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31mInstance of SmallInteger did not understand #c
[0mSmallInteger(Object)>>doesNotUnderstand: #c
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with: in Block: [ aCommand execute ]
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent: in Block: [ | selArgCount |  "show cursor in case item opens...etc...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#count was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #count
UndefinedObject>>doesNotUnderstand: #count
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with: in Block: [ aCommand execute ]
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent: in Block: [ | selArgCount |  "show cursor in case item opens...etc...
[0m[31m#count was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #count
UndefinedObject>>doesNotUnderstand: #count
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with: in Block: [ aCommand execute ]
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent: in Block: [ | selArgCount |  "show cursor in case item opens...etc...
[0m[31mInstance of Counter did not understand #counter:
[0mCounter(Object)>>doesNotUnderstand: #counter:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with: in Block: [ aCommand execute ]
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent: in Block: [ | selArgCount |  "show cursor in case item opens...etc...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31mInstance of Counter did not understand #counter:
[0mCounter(Object)>>doesNotUnderstand: #counter:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with: in Block: [ aCommand execute ]
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent: in Block: [ | selArgCount |  "show cursor in case item opens...etc...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31mInstance of Counter did not understand #increment
[0mCounter(Object)>>doesNotUnderstand: #increment
CounterTest>>testIncrement
CounterTest(TestCase)>>performTest
[self setUp.
	self performTest] in CounterTest(TestCase)>>runCase in Block: [self setUp....
FullBlockClosure(BlockClosure)>>ensure:
CounterTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [aTestCase runCase]
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase: in Block: [self runTestCaseUnderWatchdog: aTestCase]
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase: in Block: [...
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for: in Block: [ self value: anExecutionEnvironment....
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CounterTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CounterTest(TestCase)>>debug in Block: [ result runCaseForDebug: self ]
FullBlockClosure(BlockClosure)>>ensure:
CounterTest(TestCase)>>debug
CounterTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[0m[31mInstance of Counter did not understand #increment
[0mCounter(Object)>>doesNotUnderstand: #increment
CounterTest>>testIncrement
CounterTest(TestCase)>>performTest
[self setUp.
	self performTest] in CounterTest(TestCase)>>runCase in Block: [self setUp....
FullBlockClosure(BlockClosure)>>ensure:
CounterTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [aTestCase runCase]
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase: in Block: [self runTestCaseUnderWatchdog: aTestCase]
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase: in Block: [...
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for: in Block: [ self value: anExecutionEnvironment....
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CounterTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CounterTest(TestCase)>>debug in Block: [ result runCaseForDebug: self ]
FullBlockClosure(BlockClosure)>>ensure:
CounterTest(TestCase)>>debug
CounterTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[0m[31mTestFailure: Got nil instead of 0.
[0mCounterTest(TestAsserter)>>assert:description:resumable:
CounterTest(TestAsserter)>>assert:description:
CounterTest(TestAsserter)>>assert:equals:
CounterTest>>testInitialize
CounterTest(TestCase)>>performTest
[self setUp.
	self performTest] in CounterTest(TestCase)>>runCase in Block: [self setUp....
FullBlockClosure(BlockClosure)>>ensure:
CounterTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [aTestCase runCase]
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase: in Block: [self runTestCaseUnderWatchdog: aTestCase]
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase: in Block: [...
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for: in Block: [ self value: anExecutionEnvironment....
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CounterTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CounterTest(TestCase)>>debug in Block: [ result runCaseForDebug: self ]
FullBlockClosure(BlockClosure)>>ensure:
CounterTest(TestCase)>>debug
[0m[31mTestFailure: Got nil instead of 0.
[0mCounterTest(TestAsserter)>>assert:description:resumable:
CounterTest(TestAsserter)>>assert:description:
CounterTest(TestAsserter)>>assert:equals:
CounterTest>>testInitialize
CounterTest(TestCase)>>performTest
[self setUp.
	self performTest] in CounterTest(TestCase)>>runCase in Block: [self setUp....
FullBlockClosure(BlockClosure)>>ensure:
CounterTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [aTestCase runCase]
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase: in Block: [self runTestCaseUnderWatchdog: aTestCase]
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase: in Block: [...
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for: in Block: [ self value: anExecutionEnvironment....
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CounterTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CounterTest(TestCase)>>debug in Block: [ result runCaseForDebug: self ]
FullBlockClosure(BlockClosure)>>ensure:
CounterTest(TestCase)>>debug
[0m[31mInstance of Counter class did not understand #startingAt:
[0mCounter class(Object)>>doesNotUnderstand: #startingAt:
CounterTest>>testStartingAt5
CounterTest(TestCase)>>performTest
[self setUp.
	self performTest] in CounterTest(TestCase)>>runCase in Block: [self setUp....
FullBlockClosure(BlockClosure)>>ensure:
CounterTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [aTestCase runCase]
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase: in Block: [self runTestCaseUnderWatchdog: aTestCase]
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase: in Block: [...
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for: in Block: [ self value: anExecutionEnvironment....
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CounterTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CounterTest(TestCase)>>debug in Block: [ result runCaseForDebug: self ]
FullBlockClosure(BlockClosure)>>ensure:
CounterTest(TestCase)>>debug
CounterTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[0m[31mInstance of Counter class did not understand #startingAt:
[0mCounter class(Object)>>doesNotUnderstand: #startingAt:
CounterTest>>testStartingAt5
CounterTest(TestCase)>>performTest
[self setUp.
	self performTest] in CounterTest(TestCase)>>runCase in Block: [self setUp....
FullBlockClosure(BlockClosure)>>ensure:
CounterTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [aTestCase runCase]
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase: in Block: [self runTestCaseUnderWatchdog: aTestCase]
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase: in Block: [...
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for: in Block: [ self value: anExecutionEnvironment....
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
CounterTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in CounterTest(TestCase)>>debug in Block: [ result runCaseForDebug: self ]
FullBlockClosure(BlockClosure)>>ensure:
CounterTest(TestCase)>>debug
CounterTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[0m[31mInstance of SmallInteger did not understand #c
[0mSmallInteger(Object)>>doesNotUnderstand: #c
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of SmallInteger did not understand #c
[0mSmallInteger(Object)>>doesNotUnderstand: #c
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m